= Processamento Digital de Imagens

== Alunos

Flávio Mata Davim <flaviodavim@gmail.com>

Jonathan Gabriel Lima da Costa <jonathangabriel@bct.ect.ufrn.br>

:sectlinks: true
:sectnums: = true

=== Lista de Exercícios 1

Referente à Primeira Unidade da disciplina de Processamento Digital de Imagens.

==== Questão 3.1

Utilizando o programa pixels.cpp como referência, implemente um programa regions.cpp. Esse programa deverá solicitar ao usuário as coordenadas de dois pontos  P1 e P2 localizados dentro dos limites do tamanho da imagem e exibir que lhe for fornecida. Entretanto, a região definida pelo retângulo de vértices opostos definidos pelos pontos P1 e P2 será exibida com o negativo da imagem na região correspondente. O efeito é ilustrado na Figura Regiões.

image::regioes.png[]

===== Resolução

[source,c++]
----
include::regioes.cpp[]
----
	Basicamente pega-se os pontos e testa se o pixel está na região determinada, se sim, seto valor negativo do valor atual do pixel, com isso a região inteira fica com o efeito esperado.

==== Questão 3.2

Utilizando o programa pixels.cpp como referência, implemente um programa trocaregioes.cpp. Seu programa deverão trocar aleatoriamente regiões da imagem, formando uma espécie de quebra-cabeças. Explore o uso da classe Mat e seus construtores para criar as regiões que serão trocadas. O efeito é ilustrado na Figura Troca de regiões.

image::trocaregioes.png[]

===== Resolução

[source,c++]
----
include::trocaregioes.cpp[]
----
Utiliza-se o conceito de swap para trocar pixel a pixel entre as regiões que serão trocadas, afim de gerar a imagem requisitada.
==== Questão 4.1

Observando-se o programa labeling.cpp como exemplo, é possível verificar que caso existam mais de 255 objetos na cena, o processo de rotulação poderá ficar comprometido. Identifique a situação em que isso ocorre e proponha uma solução para este problema.

===== Resolução

Esse problema ocorre porque quando é feita a rotulação, o programa muda o valor em tom de cinza da bolha para que ela não seja acessada novamente. Nesse programa específico, ele não muda a cor da bolha para um valor fixo, mas sim para a cor correspondente ao número de bolhas. Resumindo, a primeira bolha vai ter a cor correspondente ao tom de cinza de valor 1, a segunda bolha corresponde ao valor 2 e assim por diante. Quando chegar à 255ª imagem, a cor da bolha será branca, que é a cor atual da bolha e isso geraria um problema de rotulação.
    Há duas maneiras de se resolver isso. A primeira é criar um “if”que iria testar o valor correspondente ao número de bolhas, se ele fosse 254 ou maior, a cor da bolha iria ser igual à 254. A outra maneira é fixar a nova cor que as bolhas vão ter desde o início, deixando ele fixo desde o começo da rotulação. 

==== Questão 4.2

Aprimore o algoritmo de contagem apresentado para identificar regiões com ou sem buracos internos que existam na cena. Assuma que objetos com mais de um buraco podem existir. Inclua suporte no seu algoritmo para não contar bolhas que tocam as bordas da imagem. Não se pode presumir, a priori, que elas tenham buracos ou não.

image::bolhas.png[]

===== Resolução

[source,c++]
----
include::holecount.cpp[]
----

[source,c++]
----
int j= 0;

    for(int i=0; i<height; i++){
      if(image.at<uchar>(i,j) == 255){      
          p.x= j;
          p.y= i;

          floodFill(image, p, 0);
        }
      if(image.at<uchar>(j,i) == 255){
          p.x= i;
          p.y= j;

          floodFill(image, p, 0);
      }
    }
----
Quando definimos j=0 e alteramos o valor de i é pra percorrer a linha e a coluna 0. Como a imagem é quadrada é possível fazer isso dentro do mesmo for. O if vai verificar quando vai haver um pixel branco e isso vai indicar que tem um bolha tocando alguma das duas laterais e por isso o programa através do floodFill transforma a bolha em preto, indicando que ela não vai entrar no cálculo, como pede a questão.

[source,c++]
----
j = height-1;

    for(int i=0; i<width; i++){
      if(image.at<uchar>(i,j) == 255){      
          p.x= j;
          p.y= i;

          floodFill(image, p, 0);
        }
      if(image.at<uchar>(j,i) == 255){
          p.x= i;
          p.y= j;

          floodFill(image, p, 0);
      }
    }
----
Essa segunda parte vai fazer o cálculo na última linha e na última coluna aproveitando a mesma idéia da primeiro for e apenas mudando o valor de j para width - 1.

[source,c++]
----
for(int i=0; i<height; i++){
      for(int j=0; j<width; j++){
        if(i==0 && j==0){
          p.x=j;
          p.y=i;
          floodFill(image,p,100);
        }
        else if(image.at<uchar>(i,j) == 255){
          // achou um objeto
          nobjects++;
          p.x=j;
          p.y=i;
          floodFill(image,p,50);
           }
           else if(image.at<uchar>(i,j) == 0){
          // achou um buraco
          noholes++;
          p.x=j;
          p.y=i;
          floodFill(image,p,200);
        }  
      }
    }
----
No último for, vamos criar um for para percorrer todos os pixels da imagem. Como tiramos todas as bolhas que estavam nas bordas, é possível afirmar que o primeiro elemento da imagem vai ter a cor de fundo da imagem, então em decorrência disso quando a posição (0,0) tiver seu valor verificado pelo floodFill, todo o background da imagem vai ser alterado pro tom de cinza de valor 100.
     Após isso vão sobrar os valores 255 referentes as bolhas e os pretos que são as bolhas, já que essas não estavam ligadas ao background e por isso não foram alteradas pela ação do floodFill.
    O nosso programa sempre que acha um valor 255 muda ele para o mesmo valor do plano de fundo pra que aquele buraco não seja mais contado e adicionamos um ao número geral de bolhas. Quando ele acha o valor 0, quer dizer que há uma bolha com buraco, então adicionamos um ao número de bolhas com buraco e mudamos o valor de 0 para 200.


==== Questão 5.1

Utilizando o programa histogram.cpp como referência, implemente um programa equalize.cpp. Este deverá, para cada imagem capturada, realizar a equalização do histogram antes de exibir a imagem. Teste sua implementação apontando a câmera para ambientes com iluminações variadas e observando o efeito gerado.

image::equalize.png[]

===== Resolução

[source,c++]
----
include::equalize.cpp[]
----
==== Questão 5.2

Utilizando o programa exemplos/histogram.cpp como referência, implemente um programa motiondetector.cpp. Este deverá continuamente calcular o histograma da imagem (apenas uma componente de cor é suficiente) e compará-lo com o último histograma calculado. Quando a diferença entre estes ultrapassar um limiar pré-estabelecido, ative um alarme. Utilize uma função de comparação que julgar conveniente.

image::trocaregioes.png[]

===== Resolução

[source,c++]
----
include::trocaregioes.cpp[]
----


